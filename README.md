# proxy-compare

[![CI](https://img.shields.io/github/actions/workflow/status/dai-shi/proxy-compare/ci.yml?branch=main)](https://github.com/dai-shi/proxy-compare/actions?query=workflow%3ACI)
[![npm](https://img.shields.io/npm/v/proxy-compare)](https://www.npmjs.com/package/proxy-compare)
[![size](https://img.shields.io/bundlephobia/minzip/proxy-compare)](https://bundlephobia.com/result?p=proxy-compare)
[![discord](https://img.shields.io/discord/627656437971288081)](https://discord.gg/MrQdmzd)

Compare two objects using accessed properties with Proxy

## Introduction

This is an internal library used in [React Tracked](https://react-tracked.js.org).

## Install

```bash
npm install proxy-compare
```

## Usage

```javascript
$ node
> const { createProxy, isChanged } = require('proxy-compare')
undefined
> state = { a: 1, b: 2 }
{ a: 1, b: 2 }
> accessed = new WeakMap()
WeakMap { [items unknown] }
> proxy = createProxy(state, accessed)
Proxy [
  { a: 1, b: 2 },
  {
    get: [Function: get],
    has: [Function: has],
    getOwnPropertyDescriptor: [Function: getOwnPropertyDescriptor],
    ownKeys: [Function: ownKeys]
  }
]
> proxy.a
1
> isChanged(state, { a: 1, b: 22 }, accessed)
false
> isChanged(state, { a: 11, b: 2 }, accessed)
true
```

## API

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

### createProxy

Create a proxy.

This function will create a proxy at top level and proxy nested objects as you access them,
in order to keep track of which properties were accessed via get/has proxy handlers:

NOTE: Printing of WeakMap is hard to inspect and not very readable; for this you can use
`getPathList`.

#### Parameters

*   `obj` **[object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)** Object that will be wrapped on the proxy.
*   `accessed` **[WeakMap](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)<[object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object), unknown>** WeakMap that will hold the tracking of which properties in the proxied object were accessed.
*   `proxyCache` **[WeakMap](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)<[object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object), unknown>?** WeakMap that will help keep referential identity for proxies.

#### Examples

```javascript
import { createProxy } from 'proxy-compare';

const nested = { e: "3" }
const original = { a: "1", c: "2", d: nested };
const accessed = new WeakMap();
const proxy = createProxy(original, accessed);

proxy.a // Marks `a` as accessed and returns "1"
// The usage is recorded in accessed:
// { original: Set("a") }

proxy.d // marks "d" as accessed and returns nested wrapped in its own tracking proxy
// The usage is recorded in accessed:
// { original: Set("a", "d") }

proxy.d.e // marks "d" as accessed on `nested` and returns "3"
// The usage is recorded in accessed:
// { parent: Set("a", "d"), nested: Set("e") }
```

Returns **[Proxy](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Proxy)<[object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)>** Object wrapped in a proxy.

### isChanged

Compare changes on objects.

This will compare the accessed properties on tracked objects inside the proxy
to check if there were any changes made to it,
by default if no property was accessed on the proxy it will attempt to do a
reference equality check for the objects provided (Object.is(a, b)). If you access a property
on the proxy, then isChanged will only compare the accessed properties.

#### Parameters

*   `prevObj` **[object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)** The previous object to compare.
*   `nextObj` **[object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)** The next object to compare with the previous one.
*   `accessed` **[WeakMap](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)<[object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object), unknown>** WeakMap that holds the tracking of which properties in the proxied object were accessed.
*   `cache` **[WeakMap](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)<[object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object), unknown>?** WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,
    and to avoid infinite loop with circular structures.

#### Examples

```javascript
import { createProxy, isChanged } from 'proxy-compare';

const obj = { a: "1", c: "2", d: { e: "3" } };
const accessed = new WeakMap();

const proxy = createProxy(obj, accessed);

proxy.a

isChanged(obj, { a: "1" }, accessed) // false

proxy.a = "2"

isChanged(obj, { a: "1" }, accessed) // true
```

Returns **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** Boolean indicating if any accessed properties on the object (or nested
fields that were accessed on tracked child objects) have changed.

### getUntracked

Unwrap proxy to get the original object.

Used to retrieve the original object used to create the proxy instance with `createProxy`.

#### Parameters

*   `obj` **[Proxy](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Proxy)<[object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)>** The proxy wrapper of the originial object.

#### Examples

```javascript
import { createProxy, getUntracked } from 'proxy-compare';

const original = { a: "1", c: "2", d: { e: "3" } };
const accessed = new WeakMap();

const proxy = createProxy(original, accessed);
const originalFromProxy = getUntracked(proxy)

Object.is(original, originalFromProxy) // true
isChanged(original, originalFromProxy, accessed) // false
```

Returns **([object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object) | null)** Return either the unwrapped object if exists.

### markToTrack

Mark object to be tracked.

This function marks an object that will be passed into `createProxy`
as marked to track or not. By default only Array and Object are marked to track,
so this is useful for example to mark a class instance to track or to mark an object
to be untracked when creating your proxy.

#### Parameters

*   `obj` **[object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)** Object to mark as tracked or not.
*   `mark`  Boolean indicating whether you want to track this object or not. (optional, default `true`)

#### Examples

```javascript
import { createProxy, markToTrack, isChanged } from 'proxy-compare';

const nested = { e: "3" }

markToTrack(nested, false)

const original = { a: "1", c: "2", d: nested };
const accessed = new WeakMap();

const proxy = createProxy(original, accessed);

proxy.d.e

isChanged(original, { d: { e: "3" } }, accessed) // true
// Even though `{ e: "3" } is structurally equivalent to `nested`, because `nested` was not
// tracked, `isChanged` sees the new `{ e: "3" }` as a new instance with no equal keys and so
// by default considers it changed.
```

Returns **any** No return.

### getPathList

Convert `accessed` to a list of paths.

Because `accessed` is a WeakMap, it is not easy to print/log for debugging.

`getPathList` converts `accessed` to a list of paths. It should primarily be used for debugging,
because `isChanged` is the canonical API for asking "are there changes?".

#### Parameters

*   `obj` **any** An object that is used with `createProxy`.
*   `accessed` **[WeakMap](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)<[object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object), any>** A weak map that is used with `createProxy`.
*   `onlyWithValues` **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)?** An optional boolean to exclude object getters.

#### Examples

```javascript
import { createProxy, markToTrack, isChanged } from 'proxy-compare';

const nested = { e: "3" }
markToTrack(nested, false)
const original = { a: "1", c: "2", d: nested };

const accessed = new WeakMap();
const proxy = createProxy(original, accessed);
proxy.a
proxy.d.e

getPathList(accessed) //  [['a'], ['d', 'e']]
```

Returns **[Array](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array)<[Array](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array)<([string](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String) | [symbol](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol))>>** An array of paths.

### affectedToPathList

Convert `accessed` to a list of paths

`accessed` is a weak map which is not printable.
This function is can convert it to printable path list.
It's for debugging purpose.

#### Parameters

*   `obj`  An object that is used with `createProxy`.
*   `accessed`  A weak map that is used with `createProxy`.
*   `onlyWithValues`  An optional boolean to exclude object getters.

Returns **any** An array of paths.

**Meta**

*   **deprecated**: Use `getPathList` instead.

### replaceNewProxy

replace newProxy function.

This can be used if you want to use proxy-polyfill.
Note that proxy-polyfill can't polyfill everything.
Use it at your own risk.

#### Parameters

*   `fn` **any**&#x20;

## Projects using this library

*   [react-tracked](https://github.com/dai-shi/react-tracked)
*   [reactive-react-redux](https://github.com/dai-shi/reactive-react-redux)
*   [svelte3-redux](https://github.com/dai-shi/svelte3-redux)
*   [proxy-memoize](https://github.com/dai-shi/proxy-memoize)
*   [valtio](https://github.com/pmndrs/valtio)

## Similar libraries

*   [proxyequal](https://www.npmjs.com/package/proxyequal)
*   [proxy-state-tree](https://www.npmjs.com/package/proxy-state-tree)
*   [proxy-watcher](https://www.npmjs.com/package/proxy-watcher)
